#!/usr/bin/env zsh
set -fexo pipefail
# Depends: qemu-system
# Suggests: virtiofsd (>= 1), podman | lxc
# -------------------------
# Value range: 1024 ~ 65535
integer ssh_port=9022

name=debian-vm-minimal
qemu_arch=x64
# -------------------------
#
# KVM & MACHINE
#
# If "/dev/kvm" does not exist, or the current architecture is incompatible with the virtual machine architecture, then it will automatically disable KVM (i.e., kvm=false).
kvm=true
#
# When KVM is not supported, it will automatically fallback.
# kvm:xen:hvf:nvmm:whpx:tcg
qemu_accel="kvm:tcg"
#
kvm_cpu=host
#
# CPU for Non-KVM:
#
# qemu-system-x86_64 -cpu help
cpu_x64=qemu64-v1
#
# qemu-system-aarch64 -cpu help
cpu_arm64=cortex-a72
#
# qemu-system-riscv64 -cpu help
cpu_rv64gc=sifive-u54
#
# la132, la464, max
cpu_loong64=la464
#
# qemu-system-mips64el -cpu help
cpu_mips64le=Loongson-3A1000
#
# qemu-system-ppc64 -cpu help
cpu_ppc64le=power8
#
# qemu-system-s390x -cpu help
cpu_s390x=max

# Symmetric multiprocessing (Multiple CPU cores)
smp=true
smp_mips64le=false
# If `smp=true`, and `max_cores=0`, then the number of cpu cores of the host is automatically detected.
integer max_cores=0

# pc (Standard PC (i440FX + PIIX, 1996)), q35 (Standard PC (Q35 + ICH9, 2009)),
# microvm, isapc, none, x-remote
machine_x64=q35
#
# qemu-system-aarch64 -machine help
machine_arm64=virt
#
# none, shakti_c, sifive_e (SiFive E), sifive_u (SiFive U), spike, virt
machine_rv64gc=virt
#
# none, virt (Loongson-3A5000 LS7A1000)
machine_loong64=virt
#
# qemu-system-mips64el -machine help
machine_mips64le=loongson3-virt
#
# qemu-system-ppc64 -machine help
machine_ppc64le=pseries
#
# qemu-system-s390x -machine help
machine_s390x=s390-ccw-virtio

extra_machine_options=(
    # virtualization=on
    #
)
# ----------------------
#
# CMD
#
qemu_cmd_x64=qemu-system-x86_64
qemu_cmd_arm64=qemu-system-aarch64
qemu_cmd_rv64gc=qemu-system-riscv64
qemu_cmd_loong64=qemu-system-loongarch64
qemu_cmd_mips64le=qemu-system-mips64el
qemu_cmd_ppc64le=qemu-system-ppc64
qemu_cmd_s390x=qemu-system-s390x

extra_qemu_args=(
    # -vnc  127.0.0.1:1
    #
    # -device  ramfb
    #
    $*
)

# NO GUI
#
# It is designed for NO GUI, if you want to use GUI, then you need to set `no_graphic=false`, and add the related arguments manually. e.g., for arm64, you may need to add the ramfb device: extra_qemu_args+=( -device ramfb )
#
no_graphic=true
# --------------
#
# DISK
#
# For virtio-blk: The 1st disk is vda, the 2nd is vdb, and the 3rd is vdc.
#
# For RAW format images, use the `.img` or `.raw` extension.
disk_arr=(
    disk.img
    #
    # var.img
    # 128GB-EXT4.img
    # 1TB-BTRFS.raw
    # 1PB-data.qcow2
    # win-data-NTFS.vhdx
)
# --------------
#
# EFI
#
# For arm64(aarch64) debian trixie (qemu 9.0-rc), efi/uboot must be enabled, otherwise the system will not boot.
enable_efi=false
enable_efi_arm64=true

efi_compatibility_mode=true

# EFI Flash Device binary image
efi_fd_file=boot/EFI.fd

#  For `grub-efi` (<= 2.12), vars is required. For `refind`, it can be absent.
enable_efi_vars=true
efi_vars_file=boot/VARS.qcow2
auto_create_efi_vars_file=true
# --------------
#
# KERNEL
#
external_kernel=true
kernel_file=boot/vmlinuz
initrd_file=boot/initrd.img
kernel_command_line="root=/dev/vda1 rw console=tty0 console=ttyS0,4000000"
kernel_command_line_arm64="root=/dev/vda1 rw console=tty0 console=ttyAMA0,4000000"
kernel_command_line_rv64gc="root=/dev/vda1 rw console=ttyS0,4000000"
kernel_command_line_ppc64le="root=/dev/vda1 rw console=tty0 console=hvc0"
kernel_command_line_s390x="root=/dev/vda1 rw console=ttysclp0"
# --------------
#
# NETWORK
#
enable_nat_network=true

# qemu-system-x86_64 -nic model=help
#
# name: "usb-net"             bus: usb-bus
# name: "virtio-net-device"   bus: virtio-bus
# name: "virtio-net-pci"      bus: PCI
#
nic_model="virtio-net-pci"
nic_model_rv64gc="virtio-net-device"

nic_compatibility_mode=false
nic_compatibility_mode_rv64gc=true
nic_compatibility_mode_s390x=true

extra_nic_options=(
    #
)

# For NAT networks, if you need to access a virtual machine's port, you must expose it.
#
# If:
#   host-addr = 8443  => 0.0.0.0:8443
#   vm-port   = 443
# then:
#   accessing `0.0.0.0:8443` is equivalent to accessing port `443` on VM.
#
# If:
#   host-addr    =  127.0.0.1:8022/tcp
#   vm-port      =  22
# then:
#   accessing `127.0.0.1:8022` is equivalent to accessing port `22` on VM.
#
#
# Map=(Key  Value)
#
# Value = optional VM internal address + VM port
#
# About Key:
#     key =  optional host address + host port + optional protocol
#
#     8443      ==  8443/tcp & 8443/udp == 0.0.0.0:8443/tcp & 0.0.0.0:8443/udp
#     8080/udp  ==  0.0.0.0:8080/udp
#     8080/tcp  ==  0.0.0.0:8080/tcp
#
local -A hostfwd_map=(
    # key                         # value
    # [host]                      # [guest] (Virtual Machine)
    # -------------------------------------
    # 8443/udp                    443
    # 8022/tcp                    22
    #
    127.0.0.1:${ssh_port}/tcp     9022
)
# --------------
#
# MEMORY
#
# Before running a virtual machine, first obtain the available memory on the host, and then allocate memory to the virtual machine based on a specific percentage of the available memory.
#
# 80 means using 80% of the host's available memory (RAM).
# 90.0 => 90.0/100.0  = 90.0%
# 5e-2 => 0.05/100.0  = 0.05%
#
# Assuming that the total memory of the host is 24G, and only 10G is available, then 80% is 8G, i.e., the VM will use 8G of memory.
# 20G available RAM *  90% =  18G
# 1T available RAM * 0.05% = 0.5G
#
# The data type of this variable is double (a.k.a., f64), f64 can take on very large values, but the actual range of values for this variable is 0.0 to 100.0
# You can only use floating point (std: IEEE 754) or integer. Attention: String will be converted to 0.000000000e+00
# Disable when 0.
float memory_percentage=90.0

# After applying `memory_percentage`, limit the maximum memory with `max_memory`.
#
# Sample 1:
#   available memory:   10G
#   memory_percentage: 50.0
#   max_memory:        4096
#   10G * 50% = 5G, since 4096M < 5G, the VM ends up using 4096M instead of 5G.
#
# Sample 2:
#   available memory:    2G
#   memory_percentage: 50.0
#   max_memory:        2048
#   2G * 50% = 1G, since 1G < 2048M, the VM ends up using 1G instead of 2048M.
#
# Disable when 0
# It is not necessary to manually add Unit (Megabytes (MB)).
integer max_memory=0

# Note: power8 cpu (arch: ppc64le) must have an integer multiple of 256M.
auto_resize_mem_to_256_multiple=false
auto_resize_mem_to_256_multiple_ppc64le=true
# --------------
#
# VIRTIO FSD
#
# Here's a description from the official website:
#
#   > Virtiofs is a shared file system that lets virtual machines access a directory tree on the host.
#   > Virtiofs is not a network file system repurposed for virtualization, it is specifically designed to take advantage of the locality of virtual machines and the hypervisor.
#   > The goal of virtiofs is to provide local file system semantics between multiple virtual machines sharing a directory tree. This is especially useful for lightweight VMs and container workloads, where shared volumes are a requirement.
#
# Note: If you have enabled virtio_fsd (i.e., virtio_fsd=true), run the following command in the virtual machine.
#
#   systemctl start media-sd.mount
#   systemctl enable media-sd.automount
#
# Finally, access the "/media/sd" directory.
#
# Requires: Host Linux Kernel >= 5.4, QEMU >= 5.0
virtio_fsd=false
shared_dir=$PWD

# To prevent virtiofsd from running as root, some isolation is required.
#
# "podman" | "lxc"
sandbox=podman
# ----------------------------
# ----------------------------
# ----------------------------
socket_dir=${XDG_RUNTIME_DIR:-/run/user/$UID}

# current_exe()?.parent()
src_dir=${0:a:h}

warn() {
    print -P >&2 -- '%F{yellow}[WARN]%f' $*
}
panic() {
    print -P >&2 -- '%F{red}[ERROR]%f' $*
    exit 1
}
info() {
    print -P >&2 -- '%F{cyan}[INFO]%f' $*
}
dbg() {
    print -P >&2 -- '%F{blue}[DEBUG]%f' $*
}
get_the_real_value() {
    local key=$1
    local var_name="${key}_${qemu_arch}"
    local value=${(P)var_name}
    if ((#value)) {
        print -R $value
        return
    }
    value=${(P)key}
    if ((! #value)) {
        panic "\$$key is empty"
    }
    print -R $value
}
# ----------------------------
hostfwd_rules=""
# anonymous function
() {
    for k v (${(kv)hostfwd_map}) {
        # k.split('/').last()
        local p=${k[(ws^/^)-1]}
        local protocol=""
        case $p {
            (tcp|udp) protocol=$p
        }

        # k.trim_end_glob("/*")
        local host=${k%/*}

        # host.split(':').collect()
        local host_arr=( ${(s^:^)host} )
        #
        local host_addr=""
        # if host_arr.len() == 2
        if (($#host_arr == 2)) {
            host_addr=$host_arr[1]
        }
        # host_arr.last()
        local host_port=$host_arr[-1]
        #
        # v.split(":").collect()
        local guest_arr=( ${(s^:^)v} )
        #
        local guest_addr=""
        # if guest_arr.len() == 2
        if (($#guest_arr == 2)) {
            guest_addr=$guest_arr[1]
        }
        # guest_arr.last()
        local guest_port=$guest_arr[-1]

        hostfwd_rules+=",hostfwd=${protocol}:${host_addr}:${host_port}-${guest_addr}:${guest_port}"
    }
}
# ----------------------------
machine_name=$(get_the_real_value machine)

unset machine_opts
for i ($extra_machine_options) {
    machine_opts+=$(printf "%s" ",$i")
}
args=(
    -machine ${machine_name},accel=${qemu_accel}${machine_opts}
    -name $name
)

() {
    enable_smp=$(get_the_real_value smp)
    if {$enable_smp} {
        local core_num=$max_cores
        if ((max_cores == 0)) {
            # Auto-detect the number of host cpu cores
            core_num=$(nproc)
        }
        args+=(
            -smp $core_num
        )
    }
}

if {$no_graphic} {
    args+=(
        -nographic
        # -vga none
        # -display none
        # -display curses
    )
}
# add disks
() {
    for disk ($disk_arr) {
        args+=-drive
        local drive_arg="file=$disk,if=virtio"

        case ${disk:e} {
            (img|raw) drive_arg+=',format=raw'
        }
        args+=$drive_arg
    }
}

args+=(
    # TL;DR. Press Ctrl+A, and then Press C, finally Press Enter.
    #
    # The STDIO is multiplexed here.
    # By default, this control sequence is Ctrl+a followed by c. (i.e., Press Ctrl+a first, then release, and then press c), you can switch between the QEMU monitor and the serial console.
    #
    # `-serial mon:stdio` is equivalent to:
    #       -chardev stdio,mux=on,id=char0
    #       -mon chardev=char0,mode=readline
    #       -serial chardev:char0
    #
    -serial  mon:stdio
)

# setup_qemu_network
() {
    if {$enable_nat_network} {
        unset nic_opts
        local nic_opts
        for i ($extra_nic_options) {
            nic_opts+=$(printf "%s" ",$i")
        }

        local real_model
        real_model=$(get_the_real_value nic_model)

        local real_cm
        real_value=$(get_the_real_value nic_compatibility_mode)

        # if nic_compatibility_mode is enabled:
        if {$real_cm} {
            args+=(
                -device ${real_model},netdev=net0
                -netdev "user,id=net0${hostfwd_rules}${nic_opts}"
            )
            return
        }

        args+=(
            -nic "user,model=${real_model}${hostfwd_rules}${nic_opts}"
        )
    }
}

# setup external kernel
() {
    if {! $external_kernel} {
        return
    }

    local cli_value

    cli_value=$(get_the_real_value kernel_command_line)

    args+=(
        -kernel  $kernel_file
        -initrd  $initrd_file
        -append  $cli_value
    )
}

# setup EFI
() {
    local efi_value

    efi_value=$(get_the_real_value enable_efi)

    if {! $efi_value} {
        return
    }

    if {$efi_compatibility_mode} {
        args+=( -bios ${efi_fd_file})
    } else {
        args+=( -drive file=${efi_fd_file},if=pflash,format=raw,unit=0,readonly=on)
    }

    if {$enable_efi_vars} {
        args+=(
            -drive file=${efi_vars_file},if=pflash,unit=1
        )
        if {$auto_create_efi_vars_file} {
            if [[ ! -e $efi_vars_file ]] {
                case $qemu_arch {
                    (rv64gc) size=32M ;;
                    (*)      size=64M ;;
                }
                qemu-img create -f qcow2 $efi_vars_file $size
            }
        }
    }
}
# ----------------------------
# MEMORY
calculate_memory() {
    if ((memory_percentage == 0.0)) {
        print $max_memory
        return
    }

    # For compatibility with `busybox free`, don't add extra arguments for `free`.
    #
    # for line in run(["free"])?.filter(|x| x.contains("Mem: "))
    for line ( ${"$(env LC_ALL=C free)"[(fr)Mem: *]} ) {
        local ava=${line[(ws^ ^)-1]}
        # /1000, not /1024
        available_memory=$((ava/1000))
        break
    }

    local mem int_mem
    mem=$((available_memory * memory_percentage/100))

    if ((max_memory == 0 || mem < max_memory)) {
        integer int_mem=$mem
        print $int_mem
        return
    }

    print $max_memory
}

memory=$(calculate_memory)

# I have tested Debian Sid (Linux 6.7.9 cloud kernel).
# If the memory is less than 96 MB, the kernel will panic.
# Even when the memory is exactly 96 MB, there is still a chance of panic.
# Therefore, it’s advisable to use a size of 97 MB+. Older systems and systems without systemd should consume less memory.
if ((memory < 96)) {
    memory=98
}

# Automatically resize the memory size to an integer multiple of 256.
() {
    local auto_resize_mem=$(get_the_real_value auto_resize_mem_to_256_multiple)

    if {$auto_resize_mem} {
        if ((memory <= 256)) {
            memory=256
            return
        }

        local remainder=$((memory % 256))

        if (( remainder == 0 )) {
            return
        }
        memory=$(( memory - remainder ))
    }
}
#
args+=(
    -m
    $memory
)
# ----------------------------
check_and_run_virtio_fsd() {
    if {! $virtio_fsd} {
        return
    }

    for vfsd_bin (${src_dir}/virtiofsd /usr/libexec/virtiofsd /usr/sbin/virtiofsd) {
        if [[ -e $vfsd_bin ]] {
            virtio_fsd=true
            break
        } else {
            virtio_fsd=false
        }
    }

    if {! $virtio_fsd} {
        warn DISABLE VIRTIO-FSD
        return
    }

    #
    if [[ ! -e $socket_dir ]] {
        mkdir -pv $socket_dir || socket_dir=$(mktemp -d)
    }

    sock_file=$socket_dir/${name}-vfsd.sock
    rm -fv $sock_file ||:
    pid_f=${sock_file}.pid
    if [[ -e $pid_f ]] {
        info "pid file: $pid_f"
        pid=$(< $pid_f)
        kill -s TERM $pid ||:
    }

    info "socket file: $sock_file"
    lxc_ns=(
        lxc-usernsexec
        -m b:0:1000:1
        -m b:1:100000:65536
    )
    podman_ns=(
        podman
        unshare
    )
    vfsd=(
        $vfsd_bin
        --socket-path=$sock_file
        --shared-dir $shared_dir
        --announce-submounts
        --sandbox chroot
    )
    case $sandbox {
        (lxc)    $lxc_ns    -- $vfsd & ;;
        (podman) $podman_ns -- $vfsd & ;;
        (*) panic "Please change the value of sandbox to 'podman' or 'lxc' (e.g., sandbox=lxc)" ;;
    }
}

add_virtio_fsd_args() {
    if {! $virtio_fsd} {
        return
    }

    args+=(
        -chardev
            "socket,id=char1,path=$sock_file"
        -device
            vhost-user-fs-pci,queue-size=1024,chardev=char1,tag=sd
        -object
            "memory-backend-memfd,id=mem,size=${memory}M,share=on"
        -numa
            node,memdev=mem
    )

    info 'Waiting for %F{blue}virtio_fsd%f socket to be created'
    # timeout 10s
    for i ({1..100}) {
        if [[ -e $sock_file ]] {
            break
        }
        info $i
        sleep 0.1
    }
    if [[ ! -e $sock_file ]] {
        panic 'Please %F{red}disable %F{cyan}VirtioFSD%f (i.e., virtio_fsd=false)'
    }
}
# ----------------------------
check_kvm() {
    if {! $kvm} {
        return
    }
    local disable_kvm=false
    local host_arch=$(uname -m)

    local -A map=(
        x86_64              x64
        amd64               x64
        aarch64             arm64
        arm64               arm64
        loongarch64         loong64
        loong64             loong64
        riscv64             rv64gc
        ppc64le             ppc64le
        ppc64el             ppc64le
        powerpc64le         ppc64le
        powerpc64el         ppc64le
        s390                s390x
        s390x               s390x
        mips64              mips64le
        mips64le            mips64le
        mips64el            mips64le
        # armhf             armv7a
        # armv7l            armv7a
    )

    if [[ $map[$host_arch]  == $qemu_arch ]] {
        if [[ ! -e /dev/kvm ]] {
            disable_kvm=true
        }
    } else {
        disable_kvm=true
    }

    if {$disable_kvm} {
        warn DISABLE KVM
        kvm=false
    }
}

set_qemu_cpu() {
    if {$kvm} {
        args+=( -cpu  $kvm_cpu )
        return
    }

    local cpu_value=$(get_the_real_value cpu)
    args+=( -cpu  $cpu_value )
}
# ----------------------------
check_and_run_virtio_fsd
add_virtio_fsd_args
check_kvm
set_qemu_cpu
cd $src_dir
# ----------------------------
qemu_cmd=$(get_the_real_value qemu_cmd)
dbg $qemu_cmd $args $extra_qemu_args

# If you want to debug it (i.e., find out what was done before running qemu), comment out the following line. (i.e., +#)
$qemu_cmd $args $extra_qemu_args
