#!/usr/bin/env zsh
set -fexo pipefail
# Depends: qemu-system
# Suggests: virtiofsd (>= 1), podman | lxc
# -------------------------
# Value range: 1024 ~ 65535
integer ssh_port=9022

# Value range: 1 ~ 65535
# This is an internal port of the virtual machine that cannot be accessed directly by the local machine if it is not exposed (mapped).
# See also: hostfwd_map
integer guest_ssh_port=9022

extra_qemu_args=(
    # -vnc  127.0.0.1:1
    #
    # -device  ramfb
    #
    # -cdrom  cloud-image.iso
    #
    $*
)

name=debian-vm-minimal
qemu_arch=x64

# NO GUI
#
# It is designed for NO GUI, if you want to use GUI, then you need to set `no_graphic=false`, and add the related arguments manually.
# e.g., for arm64, you may need to add the ramfb device: extra_qemu_args+=( -device ramfb )
# For armv7a, you also need to enable efi.
no_graphic=true
# -------------------------
#
# DISK
#
# For virtio-blk: The 1st disk is vda, the 2nd is vdb, and the 3rd is vdc.
#
# For RAW format images, use the `.img` or `.raw` extension.
disk_arr=(
    disk.img
    #
    # var.img
    # 128GB-EXT4.img
    # 1TB-BTRFS.raw
    # 1PB-data.qcow2
    # win-data-NTFS.vhdx
)
# -------------------------
#
# KVM & MACHINE
#
# Whether to enable KVM acceleration
kvm=true
#
# If "/dev/kvm" does not exist, or the current architecture is incompatible with the virtual machine architecture, then it will automatically disable KVM (i.e., kvm=false).
#
# When false, detection is skipped and KVM is forced. WARN: This may cause the VM to fail to boot.
# Note: Not all architectures are automatically detected, such as mipsle, and some other architectures that are primarily used for embedded devices.
kvm_detection=true
#
# When KVM is not supported, it will automatically fallback.
# kvm:xen:hvf:nvmm:whpx:tcg
qemu_accel="kvm:tcg"
#
kvm_cpu=host
#
# CPU for Non-KVM:
# Note: The CPU can be an empty string
#
# qemu-system-x86_64 -cpu help
cpu_x64=qemu64-v1
#
# qemu-system-i386 -cpu help
cpu_x86=qemu32-v1
#
# qemu-system-aarch64 -cpu help
cpu_arm64=cortex-a72
#
# qemu-system-arm -cpu help
cpu_armv7a=cortex-a15
#
# qemu-system-riscv64 -cpu help
cpu_rv64gc=sifive-u54
#
# la132, la464, max
cpu_loong64=la464
#
# qemu-system-ppc64 -cpu help
cpu_ppc64le=power8
#
# qemu-system-s390x -cpu help
cpu_s390x=max
# qemu-system-mips64el -cpu help
cpu_mips64le=Loongson-3A1000
#
# qemu-system-mipsel -cpu help
# 4KEc, 24Kc, 74Kf
cpu_mipsle=4KEc
#
cpu_mipsbe=""

# Symmetric multiprocessing (Multiple CPU cores)
smp=true
smp_mips64le=false
smp_mipsbe=false
smp_mipsle=false
#
# If `smp=true`, and `max_cores=0`, then the number of cpu cores of the host is automatically detected.
integer max_cores=0

# pc (Standard PC (i440FX + PIIX, 1996)), q35 (Standard PC (Q35 + ICH9, 2009)),
# microvm, isapc, none, x-remote
machine_x64=q35
#
machine_x86=pc
#
# qemu-system-aarch64 -machine help
machine_arm64=virt
#
# qemu-system-arm -machine help
machine_armv7a=virt
#
# none, shakti_c, sifive_e (SiFive E), sifive_u (SiFive U), spike, virt
machine_rv64gc=virt
#
# none, virt (Loongson-3A5000 LS7A1000)
machine_loong64=virt
#
# qemu-system-ppc64 -machine help
machine_ppc64le=pseries
#
# qemu-system-s390x -machine help
machine_s390x=s390-ccw-virtio
#
# qemu-system-mips64el -machine help
machine_mips64le=loongson3-virt
#
# qemu-system-mipsel -machine help
machine_mipsle=malta
machine_mipsbe=malta

extra_machine_options=(
    # virtualization=on
    #
)
# ----------------------
#
# EFI
#
# For arm64(aarch64) debian trixie (qemu 9.0-rc), efi/uboot must be enabled, otherwise the system will not boot.
enable_efi=false
enable_efi_arm64=true
enable_efi_loong64=true

efi_compatibility_mode=true

# EFI Flash Device binary image
efi_fd_file=boot/EFI.fd

#  For `grub-efi` (<= 2.12), vars is required. For `refind`, it can be absent.
enable_efi_vars=true
enable_efi_vars_loong64=false

efi_vars_file=boot/VARS.qcow2
auto_create_efi_vars_file=true
# --------------
#
# KERNEL
#
external_kernel=true
kernel_file=boot/vmlinuz
initrd_file=boot/initrd.img
kernel_command_line="root=/dev/vda1 rw console=tty0 console=ttyS0,4000000"
kernel_command_line_arm64="root=/dev/vda1 rw console=tty0 console=ttyAMA0,4000000"
kernel_command_line_armv7a="root=/dev/vda1 rw console=tty0 console=ttyAMA0 nokaslr"
kernel_command_line_ppc64le="root=/dev/vda1 rw console=tty0 console=hvc0"
kernel_command_line_s390x="root=/dev/vda1 rw console=ttysclp0"
kernel_command_line_mipsle="root=/dev/vda1 rw console=tty0 console=ttyS0 nokaslr"
kernel_command_line_mipsbe=$kernel_command_line_mipsle
# --------------
#
# NETWORK
#
enable_nat_network=true

# qemu-system-x86_64 -nic model=help
#
# name: "usb-net"             bus: usb-bus
# name: "virtio-net-device"   bus: virtio-bus
# name: "virtio-net-pci"      bus: PCI
#
nic_model="virtio-net-pci"
nic_model_rv64gc="virtio-net-device"

nic_compatibility_mode=false
nic_compatibility_mode_rv64gc=true
nic_compatibility_mode_s390x=true

extra_nic_options=(
    #
)

# For NAT networks, if you need to access a virtual machine's port, you must expose it.
#
# If:
#   host-addr = 8443  => 0.0.0.0:8443
#   vm-port   = 443
# then:
#   accessing `0.0.0.0:8443` is equivalent to accessing port `443` on VM.
#
# If:
#   host-addr    =  127.0.0.1:8022/tcp
#   vm-port      =  22
# then:
#   accessing `127.0.0.1:8022` is equivalent to accessing port `22` on VM.
#
#
# Map=(Key  Value)
#
# Value = optional VM internal address + VM port
#
# About Key:
#     key =  optional host address + host port + optional protocol
#
#     8443      ==  8443/tcp & 8443/udp == 0.0.0.0:8443/tcp & 0.0.0.0:8443/udp
#     8080/udp  ==  0.0.0.0:8080/udp
#     8080/tcp  ==  0.0.0.0:8080/tcp
#
local -A hostfwd_map=(
    # key                         # value
    # [host]                      # [guest] (Virtual Machine)
    # -------------------------------------
    # 8443/udp                    443
    # 8022/tcp                    22
    #
    127.0.0.1:${ssh_port}/tcp     ${guest_ssh_port}
)
# --------------
#
# MEMORY
#
# Before running a virtual machine, first obtain the available memory on the host, and then allocate memory to the virtual machine based on a specific percentage of the available memory.
#
# 80 means using 80% of the host's available memory (RAM).
# 90.0 => 90.0/100.0  = 90.0%
# 5e-2 => 0.05/100.0  = 0.05%
#
# Assuming that the total memory of the host is 24G, and only 10G is available, then 80% is 8G, i.e., the VM will use 8G of memory.
# 20G available RAM *  90% =  18G
# 1T available RAM * 0.05% = 0.5G
#
# The data type of this variable is double (a.k.a., f64), f64 can take on very large values, but the actual range of values for this variable is 0.0 to 100.0
# You can only use floating point (std: IEEE 754) or integer. Attention: String will be converted to 0.000000000e+00
# Disable when 0.
float memory_percentage=90.0

# After applying `memory_percentage`, limit the maximum memory with `max_memory`.
#
# Sample 1:
#   available memory:   10G
#   memory_percentage: 50.0
#   max_memory:        4096
#   10G * 50% = 5G, since 4096M < 5G, the VM ends up using 4096M instead of 5G.
#
# Sample 2:
#   available memory:    2G
#   memory_percentage: 50.0
#   max_memory:        2048
#   2G * 50% = 1G, since 1G < 2048M, the VM ends up using 1G instead of 2048M.
#
# Disable when 0
# It is not necessary to manually add Unit (Megabytes (MB)).
integer max_memory=0
integer max_memory_mipsle=2048
integer max_memory_mipsbe=2048
integer max_memory_armv7a=2816

# Note: power8 cpu (arch: ppc64le) must have an integer multiple of 256M.
auto_resize_mem_to_256_multiple=false
auto_resize_mem_to_256_multiple_ppc64le=true
# ----------------------
#
# CMD
#
qemu_cmd_x64=qemu-system-x86_64
qemu_cmd_x86=qemu-system-i386
qemu_cmd_arm64=qemu-system-aarch64
qemu_cmd_armv7a=qemu-system-arm
qemu_cmd_rv64gc=qemu-system-riscv64
qemu_cmd_loong64=qemu-system-loongarch64
qemu_cmd_mips64le=qemu-system-mips64el
qemu_cmd_mipsle=qemu-system-mipsel
qemu_cmd_mipsbe=qemu-system-mips
qemu_cmd_ppc64le=qemu-system-ppc64
qemu_cmd_s390x=qemu-system-s390x
# --------------
#
# VIRTIO FSD
#
# Here's a description from the official website:
#
#   > Virtiofs is a shared file system that lets virtual machines access a directory tree on the host.
#   > Virtiofs is not a network file system repurposed for virtualization, it is specifically designed to take advantage of the locality of virtual machines and the hypervisor.
#   > The goal of virtiofs is to provide local file system semantics between multiple virtual machines sharing a directory tree. This is especially useful for lightweight VMs and container workloads, where shared volumes are a requirement.
#
# Note: If you have enabled virtio_fsd (i.e., virtio_fsd=true), run the following command in the virtual machine.
#
#   systemctl start media-sd.mount
#   systemctl enable media-sd.automount
#
# Finally, access the "/media/sd" directory.
#
# Requires: Host Linux Kernel >= 5.4, QEMU >= 5.0
virtio_fsd=false
shared_dir=$PWD

# To prevent virtiofsd from running as root, some isolation is required.
#
# "podman" | "lxc"
sandbox=podman
# ----------------------------
# ----------------------------
# ----------------------------
socket_dir=${XDG_RUNTIME_DIR:-/run/user/$UID}

# current_exe()?.parent()
src_dir=${0:a:h}

warn() {
    print -P >&2 -- '%F{yellow}[WARN]%f' $*
}
panic() {
    print -P >&2 -- '%F{red}[ERROR]%f' $*
    exit 1
}
info() {
    print -P >&2 -- '%F{cyan}[INFO]%f' $*
}
dbg() {
    print -P >&2 -- '%F{blue}[DEBUG]%f' $*
}
get_the_real_value() {
    local key=$1
    local allow_empty=$2

    local var_name="${key}_${qemu_arch}"
    local value=${(P)var_name}
    if (($#value)) {
        print -R $value
        return
    }

    value=${(P)key}
    if (($#value)) {
        print -R $value
        return
    }

    if (($#allow_empty)) {
        return
    }
    panic "\$$key is empty"
}
# ----------------------------
hostfwd_rules=""
#
# update_host_forwarding_rules
() {
    for k v (${(kv)hostfwd_map}) {
        # k.split('/').last()
        local p=${k[(ws^/^)-1]}
        local protocol=""
        case $p {
            (tcp|udp) protocol=$p
        }

        # k.trim_end_glob("/*")
        local host=${k%/*}

        # host.split(':').collect()
        local host_arr=( ${(s^:^)host} )
        #
        local host_addr=""
        # if host_arr.len() == 2
        if (($#host_arr == 2)) {
            host_addr=$host_arr[1]
        }
        # host_arr.last()
        local host_port=$host_arr[-1]
        #
        # v.split(":").collect()
        local guest_arr=( ${(s^:^)v} )
        #
        local guest_addr=""
        # if guest_arr.len() == 2
        if (($#guest_arr == 2)) {
            guest_addr=$guest_arr[1]
        }
        # guest_arr.last()
        local guest_port=$guest_arr[-1]

        hostfwd_rules+=",hostfwd=${protocol}:${host_addr}:${host_port}-${guest_addr}:${guest_port}"
    }
}
# ----------------------------
args=(-name  $name)

# set_qemu_machine
() {
    local machine_opts machine_name
    machine_name=$(get_the_real_value machine allow_empty)
    if ((! $#machine_name)) {
        return
    }

    unset machine_opts
    # convert the elements of the extra_machine_options array to ",ele1,ele2,..." , equivalent to `format!(",{}", extra_machine_options.join(","))`
    for i ($extra_machine_options) {
        machine_opts+=$(printf "%s" ",$i")
    }
    args+=(
        -machine
        "${machine_name},accel=${qemu_accel}${machine_opts}"
    )
}

# SMP
() {
    enable_smp=$(get_the_real_value smp)
    if {! $enable_smp} {
        return
    }
    local core_num=$max_cores
    if ((core_num == 0)) {
        # Auto-detect the number of host cpu cores
        core_num=$(nproc)
    }
    args+=(
        -smp $core_num
    )
}

if {$no_graphic} {
    args+=(
        -nographic
        # -vga none
        # -display none
        # -display curses
    )
}
# add disks
() {
    for disk ($disk_arr) {
        args+=-drive
        local drive_arg="file=$disk,if=virtio"

        case ${disk:e} {
            (img|raw) drive_arg+=',format=raw'
        }
        args+=$drive_arg
    }
}

args+=(
    # TL;DR. Press Ctrl+A, and then Press C, finally Press Enter.
    #
    # The STDIO is multiplexed here.
    # By default, this control sequence is Ctrl+a followed by c. (i.e., Press Ctrl+a first, then release, and then press c), you can switch between the QEMU monitor and the serial console.
    #
    # `-serial mon:stdio` is equivalent to:
    #       -chardev stdio,mux=on,id=char0
    #       -mon chardev=char0,mode=readline
    #       -serial chardev:char0
    #
    -serial  mon:stdio
)

# setup_network
() {
    if {! $enable_nat_network} {
        return
    }

    local nic_opts=""
    for i ($extra_nic_options) {
        nic_opts+=$(printf "%s" ",$i")
    }

    local model=$(get_the_real_value nic_model)
    local compatibility_mode=$(get_the_real_value nic_compatibility_mode)

    if {! $compatibility_mode} {
        args+=( -nic "user,model=${model}${hostfwd_rules}${nic_opts}")
        return
    }

    # if nic_compatibility_mode is enabled:
    args+=(
        -device ${model},netdev=net0
        -netdev "user,id=net0${hostfwd_rules}${nic_opts}"
    )
}

# setup external kernel
() {
    if {! $external_kernel} {
        return
    }

    local cli_value=$(get_the_real_value kernel_command_line)

    args+=(
        -kernel  $kernel_file
        -initrd  $initrd_file
        -append  $cli_value
    )
}

# setup EFI
() {
    local enable_efi_bool=$(get_the_real_value enable_efi)

    if {! $enable_efi_bool} {
        return
    }

    if {$efi_compatibility_mode} {
        args+=( -bios ${efi_fd_file})
    } else {
        args+=( -drive file=${efi_fd_file},if=pflash,format=raw,unit=0,readonly=on)
    }

    local enable_efi_vars_bool=$(get_the_real_value enable_efi_vars)

    if {! $enable_efi_vars_bool} {
        return
    }

    args+=(
        -drive file=${efi_vars_file},if=pflash,unit=1
    )

    if {! $auto_create_efi_vars_file} {
        return
    }

    if [[ -e $efi_vars_file ]] {
        return
    }

    case $qemu_arch {
        (rv64gc) size=32M ;;
        (*)      size=64M ;;
    }
    qemu-img create -f qcow2 $efi_vars_file $size
}
# ----------------------------
# MEMORY
calculate_memory() {
    local max=$(get_the_real_value max_memory)
    if ((memory_percentage == 0.0)) {
        print $max
        return
    }

    # For compatibility with `busybox free`, don't add extra arguments for `free`.
    #
    # for line in run(["free"])?.filter(|x| x.contains("Mem: "))
    for line ( ${"$(env LC_ALL=C free)"[(fr)Mem: *]} ) {
        local ava=${line[(ws^ ^)-1]}
        # /1000, not /1024
        local available_memory=$((ava/1000))
        break
    }

    local mem=$((available_memory * memory_percentage/100))
    local int_mem

    if ((max == 0 || mem < max)) {
        integer int_mem=$mem
        print $int_mem
        return
    }

    print $max
}

memory=$(calculate_memory)

# I have tested Debian Sid (Linux 6.7.9 cloud kernel).
# If the memory is less than 96 MB, the kernel will panic.
# Even when the memory is exactly 96 MB, there is still a chance of panic.
# Therefore, it’s advisable to use a size of 97 MB+. Older systems and systems without systemd should consume less memory.
if ((memory < 96)) {
    memory=98
}

# Automatically resize the memory size to an integer multiple of 256.
() {
    local auto_resize_mem=$(get_the_real_value auto_resize_mem_to_256_multiple)

    if {! $auto_resize_mem} {
        return
    }
    if ((memory <= 256)) {
        memory=256
        return
    }

    local remainder=$((memory % 256))

    if (( remainder == 0 )) {
        return
    }
    memory=$(( memory - remainder ))
}
#
args+=(
    -m
    $memory
)
# ----------------------------
check_and_run_virtio_fsd() {
    if {! $virtio_fsd} {
        return
    }

    virtio_fsd=false
    for vfsd_bin (${src_dir}/virtiofsd /usr/libexec/virtiofsd /usr/sbin/virtiofsd) {
        if [[ -e $vfsd_bin ]] {
            virtio_fsd=true
            break
        }
    }

    if {! $virtio_fsd} {
        warn DISABLE VIRTIO-FSD
        return
    }

    #
    if [[ ! -e $socket_dir ]] {
        mkdir -pv $socket_dir || socket_dir=$(mktemp -d)
    }

    sock_file=$socket_dir/${name}-vfsd.sock
    pid_f=${sock_file}.pid
    if [[ -e $pid_f ]] {
        info "pid file: $pid_f"
        pid=$(< $pid_f)
        kill -s TERM $pid ||:
    }
    unlink $sock_file ||:

    info "socket file: $sock_file"
    lxc_ns=(
        lxc-usernsexec
        -m b:0:1000:1
        -m b:1:100000:65536
    )
    podman_ns=(
        podman
        unshare
    )
    vfsd=(
        $vfsd_bin
        --socket-path=$sock_file
        --shared-dir $shared_dir
        --announce-submounts
        --sandbox chroot
    )
    case $sandbox {
        (lxc)    $lxc_ns    -- $vfsd & ;;
        (podman) $podman_ns -- $vfsd & ;;
        (*) panic "Please change the value of sandbox to 'podman' or 'lxc' (e.g., sandbox=lxc)" ;;
    }
}

add_virtio_fsd_args() {
    if {! $virtio_fsd} {
        return
    }

    args+=(
        -chardev
            "socket,id=char1,path=$sock_file"
        -device
            vhost-user-fs-pci,queue-size=1024,chardev=char1,tag=sd
        -object
            "memory-backend-memfd,id=mem,size=${memory}M,share=on"
        -numa
            node,memdev=mem
    )

    info 'Waiting for %F{blue}virtio_fsd%f socket to be created'
    # timeout 10s
    for i ({1..100}) {
        if [[ -e $sock_file ]] {
            break
        }
        info $i
        sleep 0.1
    }
    if [[ ! -e $sock_file ]] {
        panic 'Please %F{red}disable %F{cyan}VirtioFSD%f (i.e., virtio_fsd=false)'
    }
}
# ----------------------------
detect_kvm() {
    if {! $kvm} {
        return
    }
    if {! $kvm_detection} {
        return
    }
    if [[ ! -e /dev/kvm ]] {
        warn DISABLE KVM
        kvm=false
        return
    }

    local host_arch=$(uname -m)
    local -A map=(
        x86_64              x64
        amd64               x64
        i686                x86
        i586                x86
        i486                x86
        i386                x86
        loongarch64         loong64
        loong64             loong64
        riscv64             rv64gc
        ppc64le             ppc64le
        ppc64el             ppc64le
        powerpc64le         ppc64le
        powerpc64el         ppc64le
        s390                s390x
        s390x               s390x
        mips64              mips64le
        mips64le            mips64le
        mips64el            mips64le
        aarch64             arm64
        arm64               arm64
        #
        # Linux Kernel 5.7+ no longer supports KVM for arm32.
        # See also: https://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms.git/log/?h=kvm-arm/goodbye
    )

    local tmm_arch=$map[$host_arch]

    if [[ $tmm_arch == $qemu_arch ]] {
        return
    }

    local enable_kvm=false
    # host: x64,    guest: x86         => enable-kvm
    case $tmm_arch {
        (x64)
            case $qemu_arch {
                (x86) enable_kvm=true ;;
            };;
        (mips64le)
            case $qemu_arch {
                (mipsle) enable_kvm=true ;;
            };;
    }

    if {! $enable_kvm} {
        warn DISABLE KVM
        kvm=false
    }
}

set_qemu_cpu() {
    if {$kvm} {
        if ((! $#kvm_cpu)) {
            return
        }
        args+=( -cpu  $kvm_cpu )
        return
    }

    local cpu_value=$(get_the_real_value cpu allow-empty)
    if ((! $#cpu_value)) {
        return
    }
    args+=( -cpu  $cpu_value )
}
# ----------------------------
check_and_run_virtio_fsd
add_virtio_fsd_args
detect_kvm
set_qemu_cpu
cd $src_dir
# ----------------------------
qemu_cmd=$(get_the_real_value qemu_cmd)
dbg $qemu_cmd $args $extra_qemu_args

# If you want to debug it (i.e., find out what was done before running qemu), comment out the following line. (i.e., +#)
$qemu_cmd $args $extra_qemu_args
